# Теория информации и кодирования (Прикладная математика)
Теория информации является одним из курсов при подготовке специалистов, специализирующихся в области автоматизированных систем управления и обработки информации. Функционирование таких систем существенным образом связано с получением, подготовкой, передачей, хранением и обработкой информации, поскольку без осуществления этих этапов невозможно принять правильное решение и осуществить требуемое управляющее воздействие, которое является конечной целью функционирования любой системы.
 
## Лабораторная работа № 1 «Вычисление энтропии Шеннона». 
### Цель работы:
Получить практические навыки решения задач на количественное измерение информационного объема текстовой информации.
### Теоретическая часть:
Каждое сообщение состоит из элементов, которыми могут быть символы, группы символов, буквы, слова, биты и т.д.
Сущность оптимального кодирования состоит в том, чтобы найти такой способ построения сообщения, при котором каждый элемент этого сообщения несет наибольшее количество информации. Если такой способ найден, то для передачи заданного количества информации потребуется минимальное число элементов.



## Лабораторная работа №2. «Построение оптимальных кодов».
### Цель работы:
Изучение основных принципов эффективного кодирования и приобретение практических навыков построения оптимальных кодов на примере Кодов Шеннона-Фано и Хаффмана и оценка их эффективности.
### Теоретическая часть:
***Оптимальным кодированием*** называется процедура преобразования символов первичного алфавита m1 в кодовые слова во вторичном алфавите m2, при которой средняя длина сообщений во вторичном алфавите имеет минимально возможную для данного m2 длину.

***Оптимальными*** именуются коды, представляющие кодируемые понятия кодовыми словами минимальной средней длины. Оптимальные коды относятся к классу *префиксных кодов*, т. е. каждая кодовая комбинация имеет свою длину и ни одна не является началом другой, более длиной.

В сообщениях, составленных из кодовых слов оптимального кода, статистическая избыточность сведена к минимуму, в идеальном случае – к нулю.

Основная теорема кодирования для каналов связи без шумов доказывает принципиальную возможность построения оптимальных кодов. Из нее однозначно вытекают методика построения и свойства оптимальных кодов.

Одно из основных положений этой теории заключается в том, что при кодировании сообщения, разбитого на N-буквенные блоки, можно, выбрав N достаточно большим, добиться, чтобы среднее число двоичных элементарных сигналов, приходящихся на одну букву исходного сообщения, было сколь угодно близким к H / log m. Разность будет тем меньше, чем больше Н, а Н достигает максимума при равновероятных и взаимонезависимых символах.

Отсюда вытекают основные ***свойства оптимальных кодов***:
* минимальная средняя длина кодового слова оптимального кода обеспечивается в случае, когда избыточность каждого кодового слова сведена к минимуму (в идеальном случае – к нулю);
* кодовые слова оптимального кода должны строиться из равновероятных и взаимонезависимых символов.
           
Из свойств оптимальных кодов вытекают ***принципы их построения***:
* выбор каждого кодового слова необходимо производить так, чтобы содержащееся в нем количество информации было максимальным;
* буквам первичного алфавита, имеющим большую вероятность, присваиваются более короткие кодовые слова во вторичном алфавите.

Принципы оптимального кодирования определяют методику построения оптимальных кодов.

***Построение оптимального кода по методу Шеннона-Фано*** для ансамбля из М сообщений сводится к следующей процедуре:

1) Множество из М сообщений располагают в порядке убывания вероятностей;
2) Первоначальный ансамбль кодируемых сигналов разбивают на две группы таким образом, чтобы суммарные вероятности сообщений обеих групп были по возможности равны;
3) Первой группе присваивают символ 0, второй – символ 1;
4) Каждую из групп делят на две подгруппы так, чтобы их суммарные вероятности были по возможности равны;
5) Первым подгруппам каждой из групп вновь присваивают 0, а вторым – 1, в результате получают вторые цифры кода;
6) Каждую из четырех подгрупп вновь делят на равные (с точки зрения суммарной вероятности) части до тех пор, пока в каждой из них не останется одна буква.



## Лабораторная работа №3. «Арифметическое кодирование».
### Цель работы:
Получить практические навыки кодирования и декодирования текстового файла арифметическим кодом.
### Теоретическая часть:
Идея арифметического кодирования была впервые предложена П. Элиасом. В арифметическом коде кодируемое сообщение разбивается на блоки постоянной длины, которые затем кодируются отдельно. При этом при увеличении длины блока средняя длина кодового слова стремится к энтропии, однако возрастает сложность реализации алгоритма и уменьшается скорость кодирования и декодирования. Таким образом, арифметическое кодирование позволяет получить произвольно малую избыточность при кодировании достаточно больших блоков входного сообщения.

Рассмотрим общую идею арифметического кодирования. Пусть дан источник, порождающий буквы из алфавита А={a1,a2,...,an} с вероятностями pi=P(ai), . Необходимо закодировать последовательность символов данного источника Х=х1х2х3х4.
1) Вычислим кумулятивные вероятности Q0 ,Q1,...,Qn: 
* Q0=0
* Q1=p1
* Q2=p1+p2
* Q3=p1+p2+p3 
...
* Qn=p1+p2+...+pn=1

2) Разобьем интервал [Q0,Qn) (т.е. интервал [0,1)) так, чтобы каждой букве исходного алфавита соответствовал свой интервал, равный ее вероятности (см. рис. 3.1):
* a1 [Q0,Q1) 
* a2 [Q1,Q2)
* a3 [Q2,Q3)
* a4 [Q3,Q4)
...
* an [Qn-1,Qn)

3) В процессе кодирования будем выбирать интервал, соответствующий текущей букве исходного сообщения, и снова разбивать его пропорционально вероятностям исходных букв алфавита. Постепенно происходит сужение интервала до тех пор, пока не будет закодирован последний символ кодируемого сообщения. Двоичное представление любой точки, расположенной внутри интервала, и будет кодом исходного сообщения.


## Лабораторная работа №4. «Построение кода Хемминга и исправление ошибок с его помощью».
### Цель работы:
Получить практические навыки кодирования и декодирования помехоустойчивыми кодами Хэмминга.
### Теоретическая часть:
Различают три типа помехоустойчивых кодов:
* с обнаружением ошибок;
* с исправлением ошибок;
* с обнаружением и исправлением ошибок.
Принцип построения помехоустойчивых кодов заключается в том, что все возможные кодовые комбинации N делятся на две группы: разрешенные Nи (предназначенные для передачи полезной информации) и запрещенные Nк (предназначенные для передачи информации, используемой для целей контроля).

Разрешенные и запрещенные кодовые комбинации подбираются таким образом, чтобы в результате действия любой помехи разрешенные комбинации перешли в запрещенные. Тогда на приемной стороне факт наличия ошибок всегда будет обнаружен.

Рассмотрим основные характеристики помехоустойчивых кодов.

***Значность кода n.*** Под значностью кода понимается длина кодовой комбинации.
***Число информационных символов nи.*** Информационными символами считаются те, которые непосредственно представляют соответствующую букву алфавита в кодовой комбинации.
***Число контрольных символов nк.*** Дополнительные символы, служащие для целей контроля (исправления) информации

* nк = n - nи.

***Избыточность кода l.*** Под избыточностью кода понимается относительное увеличение длины кодового слова за счет введения в него контрольных символов

* l = (n - nи) / n = 1 - nи/n.

***Кодовое расстояние d.*** Кодовое расстояние - это минимальное расстояние между двумя любыми разрешенными кодовыми комбинациями. Для двоичных сообщений определяется числом двоичных единиц, получаемых в результате суммирования по модулю два двух разрешенных кодовых комбинаций.
Для выбора кодового расстояния обычно пользуются неравенством 

* d r+s+1, (*)

где r - число ошибок, которые данный код позволяет обнаружить;
s - число ошибок, которые данный код позволяет исправить, причем r s.


## Лабораторная работа №5. «Циклическое кодирование».
### Цель работы:
Получить практические навыки построения циклического кода по заданным характеристикам и проверка его свойства по обнаружению и исправлению ошибок.
### Теоретическая часть:
Правила построения циклических кодов, исправляющих одну ошибку
Расчет соотношения между разрядами: 

* n = m + k,

где m – число проверочных разрядов;
k – число информационных разрядов;

* m = [log (n + 1)]

или:

* m = [log {(k + 1) + [log (k + 1)]}].

Выбор образующего многочлена производится по таблицам неприводимых двоичных многочленов, где m – степень многочлена, d – число единиц в комбинации.

Выбор параметров единичной матрицы производится исходя из условия, что число столбцов матрицы определяется числом информационных разрядов.

Определение элементов дополнительной матрицы производится по остаткам от деления последней строки транспонированной матрицы на образующий многочлен (это еще один способ формирования образующей матрицы).

Образующая матрица составляется путем дописывания элементов дополнительной матрицы справа от единичной матрицы или путем умножения элементов единичной матрицы на образующий многочлен.

Комбинациями исходного кода являются строки образующей матрицы и всевозможные суммы по модулю 2 различных сочетаний строк образующей матрицы.

Обнаружение и исправление ошибок происходит по остаткам от деления принятой комбинации G(X) на образующий многочлен К(Х). Если деление без остатка, то ошибки нет. Для исправления ошибки:
а) принятая комбинация делится на образующий многочлен;
б) подсчитывается вес остатка.
Если W S, где S – допустимое число исправляемых ошибок, то принятая
комбинация складывается по модулю 2 с полученным остатком. Сумма даст исправленную комбинацию.
Если W > S, то делим полученную в результате циклического сдвига комбинацию на образующий многочлен. Если в остатке W S, то складываем делимое с остатком. Затем производим циклический сдвиг вправо комбинации, полученной в результате суммирования последнего делимого с остатком. Если после первого циклического сдвига и последующего деления остаток получается таким, что его вес W > S, то процедура повторяется до тех пор, пока W S. Затем производится циклический сдвиг вправо на столько разрядов, на сколько была сдвинута принятая комбинация. В результате получаем исправленную комбинацию.
          
